/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/api/services/v2/RequestsToPay": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a cursor paged list of request to pays
         * @description Returns a cursor paged list of request to pays.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Return only objects after this cursor id. Optional */
                    after?: string;
                    /** @description Return only objects before this cursor id. Optional */
                    before?: string;
                    /** @description Upper bound for the number of objects to be returned. Defaults to 50. Maximum of 500. Optional */
                    limit?: number | null;
                    /** @description Return only objects which were created from this timestamp on. Optional. Remark: Do not use timestamps for the
                     *     paging of search results as there can be multiple objects with the same timestamp. */
                    createdFrom?: string | null;
                    /** @description Return only objects which were created until this timestamp. Optional. Remark: Do not use timestamps for the paging
                     *     of search results as there can be multiple objects with the same timestamp. */
                    createdUntil?: string | null;
                    /** @description Return only objects which were last modified from this timestamp on. Remark: Do not use timestamps for the paging
                     *     of search results as there can be multiple objects with the same timestamp. */
                    lastModifiedFrom?: string | null;
                    /** @description Return only objects which were last modified until this timestamp. Remark: Do not use timestamps for the paging
                     *     of search results as there can be multiple objects with the same timestamp. */
                    lastModifiedUntil?: string | null;
                    /** @description Return only objects with this state. Optional */
                    state?: string;
                    /** @description Return only objects with this merchant id. Optional */
                    merchantId?: string;
                    /** @description Return only objects with this connector id. Optional */
                    connectorId?: string;
                    /** @description Return only objects with this customer id. Optional */
                    customerId?: string;
                    /** @description Return only objects with this bank account id. Optional */
                    bankAccountId?: string;
                    /** @description Return only objects with this hosted page. Optional */
                    hostedPageId?: string;
                    /** @description Return only objects with this payment reference. Optional */
                    reference?: string;
                    /** @description Return only objects with this currency code. Optional */
                    currencyCode?: string;
                    /** @description Indicates whether the full customer object should be included. */
                    includeCustomer?: boolean | null;
                    /** @description Indicates whether the full bankaccount object should be included. */
                    includeBankAccount?: boolean | null;
                    /** @description Indicates whether the full mandate object should be included. */
                    includeMandate?: boolean | null;
                    /** @description Indicates whether the full connector object should be included. */
                    includeConnector?: boolean | null;
                    /** @description Indicates whether the full merchant object should be included. */
                    includeMerchant?: boolean | null;
                    /** @description Indicates whether the full hosted page object should be included. */
                    includeHostedPage?: boolean | null;
                    /** @description Custom1 for free use by the PSP. */
                    custom1?: string;
                    /** @description Custom2 for free use by the PSP. */
                    custom2?: string;
                    /** @description Custom3 for free use by the PSP. */
                    custom3?: string;
                    /** @description Custom4 for free use by the PSP. */
                    custom4?: string;
                    /** @description Custom5 for free use by the PSP. */
                    custom5?: string;
                };
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Ok. Standard response for successful HTTP requests. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["GetRequestsToPayHttpResponse"];
                    };
                };
                /** @description Bad Request. The request could not be understood by the server, usually due to malformed syntax. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Unauthorized. The client did not provide a valid authentication HTTP header or the user making the request has been disabled. */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Forbidden. The client provided a valid authentication header, but does not have permission to access this resource. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Too many requests. A rate limit has been reached. */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        /**
         * Creates a new request to pay
         * @description Creates a new request to pay. The newly created resource can be referenced by the URI given by a Location header field in the response.
         */
        post: {
            parameters: {
                query?: never;
                header?: never;
                path?: never;
                cookie?: never;
            };
            requestBody?: {
                content: {
                    "application/json": components["schemas"]["CreateRequestToPayHttpRequest"];
                };
            };
            responses: {
                /** @description Created. The request has been fulfilled and resulted in a new resource being created. */
                201: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["CreateRequestToPayHttpResponse"];
                    };
                };
                /** @description Bad Request. The request could not be understood by the server, usually due to malformed syntax. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Unauthorized. The client did not provide a valid authentication HTTP header or the user making the request has been disabled. */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Forbidden. The client provided a valid authentication header, but does not have permission to access this resource. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Conflict. The resource to be created by your request already exists. */
                409: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Too many requests. A rate limit has been reached. */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/api/services/v2/RequestsToPay/{id}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a specific request to pay
         * @description Returns a specific request to pay.
         */
        get: {
            parameters: {
                query?: {
                    /** @description Indicates whether the full customer object should be included. */
                    includeCustomer?: boolean | null;
                    /** @description Indicates whether the full bankaccount object should be included. */
                    includeBankAccount?: boolean | null;
                    /** @description Indicates whether the full mandate object should be included. */
                    includeMandate?: boolean | null;
                    /** @description Indicates whether the full connector object should be included. */
                    includeConnector?: boolean | null;
                    /** @description Indicates whether the full merchant object should be included. */
                    includeMerchant?: boolean | null;
                    /** @description Indicates whether the full hosted page object should be included. */
                    includeHostedPage?: boolean | null;
                };
                header?: never;
                path: {
                    id: string;
                };
                cookie?: never;
            };
            requestBody?: never;
            responses: {
                /** @description Ok. Standard response for successful HTTP requests. */
                200: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["GetRequestToPayHttpResponse"];
                    };
                };
                /** @description Bad Request. The request could not be understood by the server, usually due to malformed syntax. */
                400: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Unauthorized. The client did not provide a valid authentication HTTP header or the user making the request has been disabled. */
                401: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Forbidden. The client provided a valid authentication header, but does not have permission to access this resource. */
                403: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Not Found. The requested resource was not found. */
                404: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
                /** @description Too many requests. A rate limit has been reached. */
                429: {
                    headers: {
                        [name: string]: unknown;
                    };
                    content: {
                        "application/json": components["schemas"]["ErrorResponse"];
                    };
                };
            };
        };
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        CreateBankAccountHttpRequest: {
            /** @description The unique identifier of the customer this bank account object belongs to.
             *     Mandatory, unless a new customer to create is given. */
            customerId: string;
            customer: components["schemas"]["CreateCustomerHttpRequest"];
            /** @description Account holder’s given name. Will be derived from the customer's first name if not filled in. Optional. */
            accountHolder?: string;
            /** @description The ISO 13616 international bank account number. Optional when nested in hosted page. For most countries, especially in the SEPA area,
             *     using the IBAN is the preferred way to specify a bank account.
             *     Alternatively the country code and the national fields can be used. (bankCode, branchCode, accountNumber) */
            iban: string;
            /** @description The ISO 9362 business identifier code. Optional. */
            bic?: string;
            /** @description The ISO 4217 currency code. If the bank account IBAN is filled in and available, the currency code will be derived from it.
             *     If this field is not filled in the currencyCode will be set to euro by default. Optional. */
            currencyCode?: string;
            /** @description The ISO 3166-1 alpha-2 country code. If the bank account IBAN is filled in and available, the country code will be derived from it.
             *     Will be set to the german country code if empty. Optional.
             *     Note: If no IBAN is provided, the countryCode is mandatory together with the national fields. */
            countryCode?: string;
            /** @description The national bank code.
             *     Length and format depend on national regulations defined by the country code.
             *     Optional, but only if IBAN is provided.
             *     Mandatory if field for IBAN is empty and national regulations require the field to be filled in. */
            bankCode?: string;
            /** @description The national branch code. Length and format depend on national regulations defined by the country code.
             *     Optional, but only if IBAN is provided.
             *     Mandatory if field for IBAN is empty and national regulations require the field to be filled in. */
            branchCode?: string;
            /** @description The national account number. Length and format depend on national regulations defined by the country code.
             *     Optional, but only if IBAN is provided.
             *     Mandatory if field for IBAN is empty and national regulations require the field to be filled in. */
            accountNumber?: string;
            /** @description The unique idempotency key of this entity creation. Optional, but highly recommended to use.
             *     When given, SEPAexpress checks whether an entity of this type with the specified idempotency key already exists,
             *     and fails the creation if a duplicate entity is found. The ID of the conflicting entity can be found in the error message. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        /** @description The request DTO for the CreateCustomer request. */
        CreateCustomerHttpRequest: {
            /** @description The unique identifier of the merchant this customer object belongs to. */
            merchantId: string;
            /** @description Customer’s salutation. */
            salutation?: string;
            /** @description Customer’s given name. Required unless a company name is provided. */
            givenName?: string;
            /** @description Customer’s family name. Required unless a company name is provided. */
            familyName?: string;
            /** @description Customer’s company name. Required unless a given name and family name are provided. */
            companyName?: string;
            /** @description The first line of the customer’s address. */
            addressLine1?: string;
            /** @description The second line of the customer’s address. */
            addressLine2?: string;
            /** @description The third line of the customer’s address. */
            addressLine3?: string;
            /** @description The postal code of the customer’s address. */
            postalCode?: string;
            /** @description The city of the customer’s address. */
            city?: string;
            /** @description The address region, county or department of the customer’s address. */
            region?: string;
            /** @description The ISO 3166-1 alpha-2 country code of the customer’s address. */
            countryCode?: string;
            /** @description ISO 639-1 code. Used as the language for notification emails sent by SEPAexpress if
             *     your organisation does not send its own (see compliance requirements). Currently
             *     only “en”, “fr”, “de” are supported.
             *     Defaults to the country code of the address or "en" if not supported. */
            languageCode?: string;
            /** @description Customer’s email address. */
            emailAddress?: string;
            /** @description Customer’s telephone number. ITU-T E.164 formatted.
             *     When validating the customer's mobile number, please note that the following structure must be strictly followed:
             *     [+][country code][area code][subscriber number] */
            telephone?: string;
            /** @description Customer’s cellphone number. ITU-T E.164 formatted.
             *     When validating the customer's telephone number, please note that the following structure must be strictly followed:
             *     [+][country code][area code][subscriber number] */
            cellphone?: string;
            /** @description The unique idempotency key of this entity creation. Optional, but highly recommended to use.
             *     When given, SEPAexpress checks whether an entity of this type with the specified idempotency key already exists,
             *     and fails the creation if a duplicate entity is found. The ID of the conflicting entity can be found in the error message. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        CreateBankAccountBlockRulesHttpRequest: {
            /** @description The unique identifier of the merchant that the blocking rules apply to.
             *     Mandatory unless connectorId is provided. */
            merchantId: string;
            /** @description The unique identifier of the connector that the blocking rules apply to.
             *     Only mandatory if the blocking scope is intended to be limited to a single connector. */
            connectorId?: string;
            /** @description List of BankAccounts that are intended to be blocked.
             *     Already existing block rules with identical account numbers and scopes will be overwritten. */
            blockedBankAccounts: components["schemas"]["CreateBankAccountBlockRuleHttpRequest"][];
        };
        CreateBankAccountBlockRuleHttpRequest: {
            /** @description The ISO 13616 international bank account number (IBAN) that will be blocked. */
            iban: string;
            /** @description Enables or disables blocking of Payment transactions with this IBAN.
             *     Optional. Enabled by default. */
            paymentBlocked?: boolean | null;
            /** @description Enables or disables blocking of Refund transactions with this IBAN.
             *     Optional. Enabled by default. */
            refundBlocked?: boolean | null;
            /** @description Enables or disables blocking of Payout transactions with this IBAN.
             *     Optional. Enabled by default. */
            payoutBlocked?: boolean | null;
            /** @description Enables or disables blocking of RequestToPay transactions with this IBAN.
             *     Optional. Enabled by default. */
            requestToPayBlocked?: boolean | null;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        CreateBankAccountCountryBlockRuleHttpRequest: {
            /** @description The unique identifier of the merchant that the block rule applies to.
             *     Optional if connectorId is provided. */
            merchantId: string;
            /** @description The unique identifier of the connector that the block rule applies to.
             *     Only mandatory if the block scope is intended to be limited to a single connector. */
            connectorId?: string;
            /** @description The ISO 3166-1 alpha-2 country code of the country to be blocked. */
            countryCode: string;
            /** @description Enables or disables blocking of Payment transactions for this country.
             *     Optional. Enabled by default. */
            paymentBlocked?: boolean | null;
            /** @description Enables or disables blocking of Refund transactions for this country.
             *     Optional. Enabled by default. */
            refundBlocked?: boolean | null;
            /** @description Enables or disables blocking of Payout transactions for this country.
             *     Optional. Enabled by default. */
            payoutBlocked?: boolean | null;
            /** @description Enables or disables blocking of RequestToPay transactions for this country.
             *     Optional. Enabled by default. */
            requestToPayBlocked?: boolean | null;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        DeleteBankAccountBlockRulesHttpRequest: {
            /** @description The unique identifier of the merchant that the block rules apply to.
             *     Optional if connectorId is provided. */
            merchantId: string;
            /** @description The unique identifier of the connector that the block rules apply to.
             *     Optional. Mandatory if the deletion scope is intended to be limited to a single connector. */
            connectorId?: string;
            /** @description List of IBANs to be removed from the block rules. */
            ibans: string[];
        };
        DeleteBankAccountCountryBlockRuleHttpRequest: {
            /** @description The unique identifier of the merchant that the block rule applies to.
             *     Optional if connectorId is provided. */
            merchantId: string;
            /** @description The unique identifier of the connector that the block rule applies to.
             *     Mandatory if the deletion scope is intended to be limited to a single connector. */
            connectorId?: string;
            /** @description The countryCode to be deleted from the block rules. */
            countryCode: string;
        };
        /** @description The request DTO for the CreateHostedPage request */
        CreateHostedPageHttpRequest: {
            mandate: components["schemas"]["CreateMandateHttpRequest"];
            /** @description The type of this hosted page. One of:
             *     * createMandate -     The hosted page is used to create a mandate. */
            type?: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        CreateMandateHttpRequest: {
            /** @description The unique identifier of the connector this object belongs to.
             *     Optional, unless the associated merchant has more than
             *     one matching connector configured for the determined payment scheme. */
            connectorId?: string;
            /** @description The unique identifier of the bank account this mandate object belongs to.
             *     Mandatory, unless a new bank account to create is given. */
            bankAccountId: string;
            bankAccount: components["schemas"]["CreateBankAccountHttpRequest"];
            /** @description The Direct Debit payment scheme this mandate and all dependent payments belong to. Optional.
             *     Will be derived from linked bank account if not filled. Possible values:
             *
             *     * SEPA - Single Euro Payments Area
             *     * BACS - Bankers Automated Clearing Services */
            scheme?: string;
            /** @description The unique reference of this mandate.
             *     Length and format depend on the regulations defined by the determined payment scheme. Optional.
             *     If this field is not filled in, SEPAexpress generates a unique reference that meets the requirements of the determined payment scheme. */
            reference?: string;
            /** @description The type of this mandate. Optional. Possible values:
             *     * single - The mandate can be used for a single payment. It will expire after the first payment or after a period
             *     of dormancy as defined by the payment scheme.
             *     * recurring - The mandate can be used for an unlimited number of payments. It will expire after a period of
             *     dormancy as defined by the payment scheme. This is the default. */
            type?: string;
            /** @description The approvalBy specifies the way the customer approves the mandate. Optional. Possible values:
             *     * **click** - Click mandate. The mandate is approved by ticking a check box and/or clicking an approve button on the web page.
             *     * **email** - Email mandate. The customer receives an email containing a secret Tan or a link to click.
             *                   The field emailAddress inside of the customer object is required to contain a valid email address to sign via email.
             *     * **sms** -   SMS mandate. The customer receives a sms containing a secret Tan.
             *                   The field cellphone inside of the customer object is required to contain a valid cellphone number to sign via sms.
             *     * **ais** -   Account Information Service mandate. The mandate is approved by using a PSD2 AIS account check via the online
             *                   banking of the customer's bank. When the amount and currency are provided, an additional balance check is executed.
             *     * **dynamic** - Dynamic mandate management. The mandate type is managed by SEPAexpress based on configured parameters. */
            approvalBy?: string;
            /** @description The unique idempotency key of this entity creation. Optional, but highly recommended to use.
             *     When given, SEPAexpress checks whether an entity of this type with the specified idempotency key already exists,
             *     and fails the creation if a duplicate entity is found. The ID of the conflicting entity can be found in the error message. */
            idempotencyKey?: string;
            /**
             * Format: date-time
             * @description The field ApprovalDate indicates when the mandate was signed. Optional.
             */
            approvalDate?: string | null;
            /** @description The ISO 4217 currency code.
             *     **Note**: This field is only required when creating an AIS mandate and an additional balance check should be executed. Must be sent in combination with the field <u>amount</u>! */
            currencyCode: string;
            /**
             * Format: int32
             * @description The field <u>amount</u> specifies the amount the account should be checked for when creating an AIS mandate.
             *     Specified in the smallest subunit of the used currency, e.g. cents for EUR.
             *     **Note**: This field is only required when creating an AIS mandate and an additional balance check should be executed. Must be sent in combination with the field <u>currency code</u>!
             */
            amount: number | null;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        ApproveMandateHttpRequest: {
            /** @description The unique identifier of the mandate object. */
            id?: string;
            /** @description The approval Tan. */
            tan?: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        ResendMandateHttpRequest: {
            /** @description The unique identifier of the mandate object. */
            id: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        ReviewMandateHttpRequest: {
            /** @description The unique identifier of the mandate object. */
            id: string;
            /** @description Possible values:
             *     * accept - Accept the creation of this mandate.
             *     * reject - Reject the creation of this mandate. */
            action?: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        DiscardMandateHttpRequest: {
            /** @description The Id */
            id: string;
            /** @description Memo for free use by the PSP */
            memo?: string;
        };
        ReinstateMandateHttpRequest: {
            /** @description The unique identifier of the mandate object. */
            id: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        CreatePaymentHttpRequest: {
            /** @description The unique identifier of the mandate this payment object belongs to.
             *     Mandatory, unless a new mandate to create is given. */
            mandateId: string;
            mandate: components["schemas"]["CreateMandateHttpRequest"];
            /** @description The ISO 4217 currency code. */
            currencyCode: string;
            /**
             * Format: int32
             * @description The amount to be collected from the customer's bank account.
             *     Specified in the smallest subunit of the used currency, e.g.
             *     cents for EUR.
             */
            amount: number;
            /** @description The unique reference of this payment. This id is used for matching payments and refunds on the
             *     participating bank accounts. Length, format and content depend on the regulations defined
             *     by the determined payment scheme. Often called End2EndId in the SEPA scheme. Optional. */
            reference?: string;
            /** @description The soft descriptor for this payment. The text entered here will be
             *     printed on the bank statements of the participating bank accounts,
             *     if supported in the used payment scheme. Optional.
             *     SEPAexpress will generate a scheme compliant soft descriptor, if left empty. */
            softDescriptor?: string;
            /**
             * Format: date-time
             * @description Defines when this payment should be earliest submitted
             *     to the customer's bank account. Optional.
             *     Payments will be submitted as soon as possible, if not specified.
             */
            submitAfter?: string | null;
            /** @description The unique idempotency key of this entity creation. Optional, but highly recommended to use.
             *     When given, SEPAexpress checks whether an entity of this type with the specified idempotency key already exists,
             *     and fails the creation if a duplicate entity is found. The ID of the conflicting entity can be found in the error message. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding IBAN of the stored mandate. */
            validationIban?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding id of the stored customer. */
            validationCustomerId?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding id of the stored bank account. */
            validationBankAccountId?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding id of the stored connector. */
            validationConnectorId?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding id of the stored merchant. */
            validationMerchantId?: string;
            /** @description Optional. Mark this payment as not yet approved by the customer.
             *     SEPAexpress will initiate the approval process. One of:
             *     * ais - Account Information Service mandate. The customer is redirected to his selected bank login and after successful authorization he gets redirected back to merchant site. */
            approvalBy?: string;
            /** @description Custom1 for free use by the PSP. */
            custom1?: string;
            /** @description Custom2 for free use by the PSP. */
            custom2?: string;
            /** @description Custom3 for free use by the PSP. */
            custom3?: string;
            /** @description Custom4 for free use by the PSP. */
            custom4?: string;
            /** @description Custom5 for free use by the PSP. */
            custom5?: string;
        };
        ReviewPaymentHttpRequest: {
            /** @description The unique identifier of the payment object. */
            id: string;
            /** @description Possible values:
             *     * accept - Accept the creation of this payment
             *     * reject - Reject the creation of this payment */
            action?: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        CreatePayoutHttpRequest: {
            /** @description The unique identifier of the connector this object belongs to.
             *     Optional. Mandatory if the associated merchant has more than
             *     one matching connector configured for the determined payout scheme. */
            connectorId?: string;
            /** @description The unique identifier of the bank account this payout object belongs to.
             *     Mandatory, unless a new bank account to create is given. */
            bankAccountId: string;
            bankAccount: components["schemas"]["CreateBankAccountHttpRequest"];
            /** @description The Direct Debit payment scheme to which this mandate and all dependent
             *     payments belong. Optional. Will be derived from the associated
             *     bank account if left empty.
             *     Possible values:
             *     * sepa - Single Euro Payments Area
             *     * bacs - Bankers Automated Clearing Services */
            scheme?: string;
            /** @description The ISO 4217 currency code. */
            currencyCode: string;
            /**
             * Format: int32
             * @description The amount to be paid out to the customer's bank account.
             *     Specified in the smallest subunit of the used currency, e.g.
             *     cents for EUR.
             */
            amount: number | null;
            /** @description The unique reference of this payment. This id is used for matching
             *     payments and refunds on the participating bank accounts. Length, format
             *     and content depend on the regulations defined by the determined payment scheme.
             *     Often called End2EndId in the SEPA scheme. Optional. */
            reference?: string;
            /** @description The soft descriptor for this payout. The text entered here will be
             *     printed on the bank statements of the participating bank accounts,
             *     if supported in the used payment scheme. Optional. SEPAexpress will
             *     generate a scheme compliant soft descriptor, if left empty. */
            softDescriptor?: string;
            /**
             * Format: date-time
             * @description Defines when this payout should be earliest submitted
             *     to the customer's bank account. Optional. Payouts will
             *     be submitted as soon as possible, if not specified.
             */
            submitAfter?: string | null;
            /** @description The unique idempotency key of this entity creation. Optional, but highly recommended to use.
             *     When given, SEPAexpress checks whether an entity of this type with the specified idempotency key already exists,
             *     and fails the creation if a duplicate entity is found. The ID of the conflicting entity can be found in the error message. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding IBAN of the stored mandate. */
            validationIban?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding id of the stored customer. */
            validationCustomerId?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding id of the stored connector. */
            validationConnectorId?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding id of the stored merchant. */
            validationMerchantId?: string;
            /** @description Custom1 for free use by the PSP. */
            custom1?: string;
            /** @description Custom2 for free use by the PSP. */
            custom2?: string;
            /** @description Custom3 for free use by the PSP. */
            custom3?: string;
            /** @description Custom4 for free use by the PSP. */
            custom4?: string;
            /** @description Custom5 for free use by the PSP. */
            custom5?: string;
        };
        ReviewPayoutHttpRequest: {
            /** @description The unique identifier of the payout object. */
            id: string;
            /** @description Possible values:
             *     * accept - Accept the creation of this payout
             *     * reject - Reject the creation of this payout */
            action?: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        CreateRefundHttpRequest: {
            /** @description The unique identifier of the payment this refund object belongs to. Required unless a paymentReference is provided. */
            paymentId?: string;
            /** @description The reference of the payment this refund object belongs to. Required unless a paymentId is provided. */
            paymentReference?: string;
            /** @description The ISO 4217 currency code. */
            currencyCode?: string;
            /**
             * Format: int32
             * @description The amount to be sent to the customer's bank account.
             *     Specified in the smallest subunit of the used currency, e.g.
             *     cents for EUR. Optional. The entire remaining refundable
             *     amount of the associated payment will be refunded, if left empty.
             */
            amount?: number | null;
            /** @description The soft descriptor for this refund. The text entered here will be
             *     printed on the bank statements of the participating bank accounts,
             *     if supported in the used payment scheme. Optional. SEPAexpress will
             *     generate a scheme compliant soft descriptor, if left empty. */
            softDescriptor?: string;
            /**
             * Format: date-time
             * @description Defines when this refund should be earliest submitted
             *     to the customer's bank account. Optional. Refunds will
             *     be submitted as soon as possible, if not specified.
             */
            submitAfter?: string | null;
            /** @description The unique idempotency key of this entity creation. Optional, but highly recommended to use.
             *     When given, SEPAexpress checks whether an entity of this type with the specified idempotency key already exists,
             *     and fails the creation if a duplicate entity is found. The ID of the conflicting entity can be found in the error message. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding id of the stored customer. */
            validationCustomerId?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding id of the stored bank account. */
            validationBankAccountId?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding id of the stored connector. */
            validationConnectorId?: string;
            /** @description If provided, it will result in a validation error if the content does not match the corresponding id of the stored merchant. */
            validationMerchantId?: string;
            /** @description Custom1 for free use by the PSP. */
            custom1?: string;
            /** @description Custom2 for free use by the PSP. */
            custom2?: string;
            /** @description Custom3 for free use by the PSP. */
            custom3?: string;
            /** @description Custom4 for free use by the PSP. */
            custom4?: string;
            /** @description Custom5 for free use by the PSP. */
            custom5?: string;
        };
        ReviewRefundHttpRequest: {
            /** @description The unique identifier of the payment object. */
            id?: string;
            /** @description Possible values:
             *     * accept - Accept the creation of this refund
             *     * reject - Reject the creation of this refund */
            action?: string;
            /** @description Memo for free use by the PSP. */
            memo?: string;
        };
        CreateRequestToPayHttpRequest: {
            /** @description The unique identifier of the connector this object belongs to.
             *     Optional. Mandatory if the associated merchant has more than
             *     one matching connector configured for the determined payment scheme. */
            connectorId?: string;
            /** @description The unique identifier of the bank account this mandate object belongs to.
             *     Mandatory, unless a new bank account to create is given. */
            bankAccountId?: string;
            bankAccount?: components["schemas"]["CreateBankAccountHttpRequest"];
            /** @description The ISO 4217 currency code. */
            currencyCode?: string;
            /**
             * Format: int32
             * @description The amount to collect from the customer's bank account.
             *     Specified in the smallest subunit of the used currency, e.g.
             *     cents for EUR.
             */
            amount?: number;
            /** @description The unique reference of this requestToPay. This id is used for matching
             *     requestToPays and refunds on the participating bank accounts. Length,
             *     format and content are dependent on the regulations defined by
             *     the used requestToPay scheme. Often called End2EndId in the SEPA scheme. */
            reference?: string;
            /** @description The soft descriptor for this requestToPay. The text entered here will be
             *     printed on the bank statements of the participating bank accounts,
             *     if supported in the used requestToPay scheme. Optional. SEPAexpress will
             *     generate a scheme compliant soft descriptor, when left empty. */
            softDescriptor?: string;
            /** @description The unique idempotency key of this entity creation.
             *     Optional, but highly recommended to use. When given, SEPAexpress
             *     will check, whether an entity of this type with the given
             *     idempotency key does already exist, and will fail the creation,
             *     if a duplicate entity is found. The error message will contain
             *     the id of the conflicting entity. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP */
            memo?: string;
            /** @description Custom1 for free use by the PSP. */
            custom1?: string;
            /** @description Custom2 for free use by the PSP. */
            custom2?: string;
            /** @description Custom3 for free use by the PSP. */
            custom3?: string;
            /** @description Custom4 for free use by the PSP. */
            custom4?: string;
            /** @description Custom5 for free use by the PSP. */
            custom5?: string;
        };
        CreateBankAccountHttpResponse: {
            bankAccount?: components["schemas"]["BankAccount"];
        };
        /** @description Parameters of a bank account object */
        BankAccount: {
            /** @description The unique identifier of this bank account object. */
            id: string;
            /** @description The unique identifier of the merchant this bank account object belongs to. */
            merchantId: string;
            merchant?: components["schemas"]["Merchant"];
            /** @description The unique identifier of the customer this bank account object belongs to. */
            customerId: string;
            customer?: components["schemas"]["Customer"];
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this bank account object was created
             */
            createdAt: string;
            /** @description One of:
             *     * created - The bank account is created and its id can be immediately used in subsequent calls to the API. The
             *     execution of dependent subsequent calls will get postponed until this bank account object gets active.
             *     * active - The bank account has been successfully set up.
             *     * failed - The bank account could not be set up.
             *     * discarded - The bank account has been discarded.
             *     * expired - The bank account has expired due to dormancy. */
            state?: string;
            /** @description Account holder’s company name. */
            accountHolder?: string;
            /** @description The ISO 13616 international bank account number */
            iban?: string;
            /** @description The ISO 9362 business identifier code */
            bic?: string;
            /** @description The ISO 4217 currency code. */
            currencyCode?: string;
            /** @description The ISO 3166-1 alpha-2 country code. */
            countryCode?: string;
            /** @description The national bank code. Length and format dependent
             *     on national regulations defined by the country code. */
            bankCode?: string;
            /** @description The national branch code. Length and format dependent
             *     on national regulations defined by the country code. */
            branchCode?: string;
            /** @description The national account number. Length and format dependent
             *     on national regulations defined by the country code. */
            accountNumber?: string;
            /** @description The unique idempotency key of this entity creation.
             *     Optional, but highly recommended to use. When given, SEPAexpress
             *     will check, whether an entity of this type with the given
             *     idempotency key does already exist, and will fail the creation,
             *     if a duplicate entity is found. The error message will contain
             *     the id of the conflicting entity. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP */
            memo?: string;
        };
        /** @description Parameters of a merchant object */
        Merchant: {
            /** @description The unique identifier of this merchant object. */
            id: string;
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this merchant object was created
             */
            createdAt: string;
            /** @description One of:
             *     * created - The merchant is created and its id can be immediately used in subsequent calls to the API. The
             *     execution of dependent subsequent calls will get postponed until this merchant object gets active.
             *     * pendingOnboarding - The onboarding for the merchant is pending.
             *     * pendingGoLive - The go live for the merchant is pending.
             *     * active - The merchant has been successfully set up.
             *     * failed - The merchant could not be set up.
             *     * discarded - The merchant has been discarded.
             *     * expired - The merchant has expired due to dormancy. */
            state: string;
            /** @description Merchant's name. */
            name: string;
            /** @description Memo for free use by the PSP */
            memo?: string;
            /** @description Configuration for the merchant */
            configuration?: string;
        };
        /** @description Parameters of a customer object */
        Customer: {
            /** @description The unique identifier of this customer object. */
            id: string;
            /** @description The unique identifier of the merchant this customer object belongs to. */
            merchantId: string;
            merchant?: components["schemas"]["Merchant"];
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this customer object was created
             */
            createdAt: string;
            /** @description One of:
             *     * created - The customer is created and its id can be immediately used in subsequent calls to the API. The
             *     execution of dependent subsequent calls will get postponed until this customer object gets active.
             *     * active - The customer has been successfully set up.
             *     * failed - The customer could not be set up.
             *     * discarded - The customer has been discarded.
             *     * expired - The customer has expired due to dormancy. */
            state: string;
            /** @description Customer’s salutation */
            salutation?: string;
            /** @description Customer’s given name. Required unless a company name is provided */
            givenName?: string;
            /** @description Customer’s family name. Required unless a company name is provided */
            familyName?: string;
            /** @description Customer’s company name. Required unless a given name and family name are provided */
            companyName?: string;
            /** @description The first line of the customer’s address */
            addressLine1?: string;
            /** @description The second line of the customer’s address */
            addressLine2?: string;
            /** @description The third line of the customer’s address */
            addressLine3?: string;
            /** @description The postal code of the customer’s address */
            postalCode?: string;
            /** @description The city of the customer’s address */
            city?: string;
            /** @description The address region, county or department of the customer’s address */
            region?: string;
            /** @description The ISO 3166-1 alpha-2 country code of the customer’s address. */
            countryCode?: string;
            /** @description ISO 639-1 code. Used as the language for notification emails sent by SEPAexpress if
             *     your organization does not send its own (see compliance requirements). Currently
             *     only “en”, “fr”, “de” are supported.
             *     Defaults to the country code of the address or "en" if not supported */
            languageCode: string;
            /** @description Customer’s email address. */
            emailAddress?: string;
            /** @description Customer’s telephone number. ITU-T E.164 formatted. */
            telephone?: string;
            /** @description Customer’s cellphone number. ITU-T E.164 formatted. */
            cellphone?: string;
            /** @description The unique idempotency key of this entity creation.
             *     Optional, but highly recommended to use. When given, SEPAexpress
             *     will check, whether an entity of this type with the given
             *     idempotency key does already exist, and will fail the creation,
             *     if a duplicate entity is found. The error message will contain
             *     the id of the conflicting entity. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP */
            memo?: string;
        };
        /** @description The response DTO for an erroneous request */
        ErrorResponse: {
            error: components["schemas"]["Error"];
        };
        /** @description Parameters of an error object */
        Error: {
            /** @description The unique identifier of this object. */
            id: string;
            /**
             * Format: int32
             * @description The status code of this error.
             */
            code: number;
            /** @description The error message. */
            message: string;
            /** @description The reason code. */
            reasonCode?: string;
            /** @description The cause. */
            cause?: string;
            /** @description The trigger. */
            trigger?: string;
            /** @description The token. */
            token?: string;
            /** @description The description. */
            description?: string;
            /** @description The action. */
            action?: string;
            /** @description The best practice. */
            bestPractice?: string;
            /** @description List of error details. */
            details?: components["schemas"]["ErrorDetail"][];
        };
        /** @description Parameters of an error detail object */
        ErrorDetail: {
            /** @description The error detail message. */
            message: string;
            /** @description List of fields. */
            fields?: string[];
        };
        /** @description The response model for cursor-based paged bank account list. */
        GetBankAccountsHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of bank accounts. */
            bankAccounts?: components["schemas"]["BankAccount"][];
        };
        /** @description Paging meta data */
        CursorPagedMeta: {
            /** @description The unique identifier of the first item that has been returned. */
            before?: string;
            /** @description The unique identifier of the last item that has been returned. */
            after?: string;
            /**
             * Format: int32
             * @description The upper bound placed on the number of items returned. If there were not enough
             *     remaining items in the list of data then fewer than this number will have been returned.
             */
            limit: number;
            /**
             * Format: int32
             * @description The number of items returned.
             */
            count: number;
        };
        /** @description The response DTO for the GetBankAccount request */
        GetBankAccountHttpResponse: {
            bankAccount: components["schemas"]["BankAccount"];
        };
        CreateBankAccountBlockRulesHttpResponse: {
            /** @description Optional response message. */
            responseMessage?: string;
        };
        /** @description The DTO for the CreateBankAccountBlockRules request */
        GetBankAccountBlockRulesHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of bank account block rules. */
            blockRules?: components["schemas"]["BankAccountBlockRule"][];
        };
        BankAccountBlockRule: {
            /** @description The unique identifier of this bank account object. */
            id?: string;
            /** @description The ISO 13616 international bank account number */
            iban?: string;
            /** @description The ISO 3166-1 alpha-2 country code. */
            countryCode?: string;
            /** @description The unique identifier of the merchant this block rule object belongs to. */
            merchantId?: string;
            /** @description The unique identifier of the connector this block rule object belongs to. */
            connectorId?: string;
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this object was created
             */
            createdAt?: string;
            /** @description Memo for free use by the PSP */
            memo?: string;
            /** @description Indicator whether Payment transactions are blocked for this BankAccount. */
            paymentBlocked?: boolean;
            /** @description Indicator whether Refund transactions are blocked for this BankAccount. */
            refundBlocked?: boolean;
            /** @description Indicator whether Payout transactions are blocked for this BankAccount. */
            payoutBlocked?: boolean;
            /** @description Indicator whether RequestToPay transactions are blocked for this BankAccount. */
            requestToPayBlocked?: boolean;
            blockScope?: string;
        };
        CreateBankAccountCountryBlockRuleHttpResponse: {
            /** @description Optional response message. */
            responseMessage?: string;
        };
        DeleteBankAccountBlockRulesHttpResponse: {
            /** @description Optional response message. */
            responseMessage?: string;
        };
        DeleteBankAccountCountryBlockRuleHttpResponse: {
            /** @description Optional response message. */
            responseMessage?: string;
        };
        /** @description The response DTO for the GetConnector request */
        GetConnectorHttpResponse: {
            connector: components["schemas"]["Connector"];
        };
        /** @description Parameters of a connector object */
        Connector: {
            /** @description The unique identifier of this connector object. */
            id: string;
            /** @description The unique identifier of the merchant this connector object belongs to. */
            merchantId: string;
            merchant?: components["schemas"]["Merchant"];
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this connector object was created
             */
            createdAt: string;
            /** @description One of:
             *     * created - The connector is created and its id can be immediately used in subsequent calls to the API. The
             *     execution of dependent subsequent calls will get postponed until this connector object gets active.
             *     * pendingOnboarding - The onboarding for the merchant is pending.
             *     * active - The connector has been successfully set up.
             *     * failed - The connector could not be set up.
             *     * discarded - The connector has been discarded.
             *     * expired - The connector has expired due to dormancy. */
            state: string;
            /** @description The name of this connector object. */
            name?: string;
            /** @description The payment scheme this connector belongs to. Optional.
             *     Will be derived from the linked settlement IBAN when not filled.
             *     One of:
             *     * sepa - Single Euro Payments Area
             *     * bacs - Bankers Automated Clearing Services */
            scheme: string;
            /** @description One of:
             *     * payment - The connector is used to collect payments from customers.
             *     * payout - The connector is used to payout money to customers. */
            type: string;
            /** @description Optional. One of:
             *     * generate - mandate documents will be generated for newly created payment mandates.
             *     * archive - mandate documents will be generated and archived for newly created payment mandates.
             *     * send - mandate documents will be generated, archived and sent to the customer for newly created payment mandates. */
            mandateHandling?: string;
            /** @description Optional. One of:
             *     * generate - mandate setup confirmation documents will be generated for newly created payment mandates.
             *     * archive - mandate setup confirmation documents will be generated and archived for newly created payment mandates.
             *     created payment mandates. */
            mandateSetupConfirmationHandling?: string;
            /** @description Optional. One of:
             *     * generate - payment pre notification documents will be generated for newly created payments.
             *     * archive - payment pre notification documents will be generated and archived for newly created payments.
             *     * send - payment pre notification documents will be generated, archived and sent to the customer for newly created
             *     payments. */
            paymentPreNotificationHandling?: string;
            /** @description Optional. One of:
             *     * wait - requestToPay will wait after being submitted */
            requestToPayHandling?: string;
            mandateReviewEnabled?: boolean;
            paymentReviewEnabled?: boolean;
            payoutReviewEnabled?: boolean;
            refundReviewEnabled?: boolean;
            /** @description Memo for free use by the PSP */
            memo?: string;
            schemeConfiguration?: components["schemas"]["SepaConfiguration"];
        };
        SepaConfiguration: {
            creditorId?: string;
            paymentProcessorName?: string;
            payoutProcessorName?: string;
            refundProcessorName?: string;
            requestToPayProcessorName?: string;
            /** Format: int32 */
            refundQueuingDays?: number;
            debtCollection?: boolean;
            emailConfig?: components["schemas"]["emailConfig"];
            smsConfig?: components["schemas"]["smsConfig"];
            riskCheckConfiguration?: components["schemas"]["riskCheckConfiguration"];
            pspName?: string;
            b4PId?: string;
            isCompanyDirectDebit?: boolean;
            isCompanyDirectDebitB2C?: boolean;
            enforceAis?: boolean;
            aisConfiguration?: components["schemas"]["aisConfiguration"];
            rtpConfiguration?: components["schemas"]["rtpConfiguration"];
            hostedPagesConfiguration?: components["schemas"]["HostedPagesConfigurationDto"];
            dynamicMandateConfiguration?: components["schemas"]["DynamicMandateConfigurationDto"];
            templateConfiguration?: components["schemas"]["templateConfiguration"];
            tokenIoConfig?: components["schemas"]["tokenIoConfig"];
            finTsConfig?: components["schemas"]["finTsConfig"];
            ixoConfig?: components["schemas"]["ixoConfig"];
            tinkConfig?: components["schemas"]["TinkConfig"];
        };
        emailConfig: {
            fromName?: string;
            fromEmail?: string;
        };
        smsConfig: {
            fromName?: string;
            accountSid?: string;
            authToken?: string;
        };
        riskCheckConfiguration: {
            enabled?: boolean;
            /** Format: int32 */
            mandateMinAmount?: number;
            /** Format: int32 */
            mandateMaxAmount?: number;
            /** Format: int32 */
            paymentMinAmount?: number;
            /** Format: int32 */
            paymentMaxAmount?: number;
            /** Format: int32 */
            requestToPayMinAmount?: number;
            /** Format: int32 */
            requestToPayMaxAmount?: number;
            historicalBalanceCheckTimeSpan?: components["schemas"]["TimeSpan"];
            paymentMaxCountPerPeriod?: components["schemas"]["countPerTimeSpan"][];
            requestToPayMaxCountPerPeriod?: components["schemas"]["countPerTimeSpan"][];
        };
        TimeSpan: {
            /** Format: int64 */
            readonly ticks?: number;
            /** Format: int32 */
            readonly days?: number;
            /** Format: int32 */
            readonly hours?: number;
            /** Format: int32 */
            readonly milliseconds?: number;
            /** Format: int32 */
            readonly minutes?: number;
            /** Format: int32 */
            readonly seconds?: number;
            /** Format: double */
            readonly totalDays?: number;
            /** Format: double */
            readonly totalHours?: number;
            /** Format: double */
            readonly totalMilliseconds?: number;
            /** Format: double */
            readonly totalMinutes?: number;
            /** Format: double */
            readonly totalSeconds?: number;
        };
        countPerTimeSpan: {
            /** Format: int32 */
            count?: number;
            timeSpan?: components["schemas"]["TimeSpan"];
        };
        aisConfiguration: {
            routes?: components["schemas"]["aisProviderRoute"][];
            lastSyncDifferenceTimeSpan?: components["schemas"]["TimeSpan"];
            continuousAccess?: boolean;
        };
        aisProviderRoute: {
            countryCode?: string;
            bic?: string;
            providers?: ("Unknown" | "TokenIo" | "FinTs" | "FinTsRisk" | "TinkAis")[];
        };
        rtpConfiguration: {
            routes?: components["schemas"]["rtpProviderRoute"][];
            lastSyncDifferenceTimeSpan?: components["schemas"]["TimeSpan"];
            destinationAccount?: string;
            recipientName?: string;
            paymentScheme?: string;
        };
        rtpProviderRoute: {
            countryCode?: string;
            bic?: string;
            providers?: ("Unknown" | "TinkPis" | "Ixo" | "TokenIoPis")[];
        };
        HostedPagesConfigurationDto: {
            styles?: components["schemas"]["HostedPagesConnectorStylesDto"];
            /** @description "ACCOUNT_HOLDER" | "COMPANY_NAME" | "FIRST_AND_LAST_NAME" */
            requiredNameField?: string;
            hideAllInputs?: boolean;
        };
        HostedPagesConnectorStylesDto: {
            logoUrl?: string;
            primaryColor?: string;
            backgroundColor?: string;
            borderRadius?: string;
        };
        DynamicMandateConfigurationDto: {
            amounts?: components["schemas"]["DynamicMandateAmountDto"][];
        };
        DynamicMandateAmountDto: {
            approvalBy?: string;
            /** Format: int32 */
            amount?: number | null;
        };
        templateConfiguration: {
            creditorStreetNameAndNumber?: string;
            creditorPostalCodeCity?: string;
            merchantLogo?: string;
        };
        tokenIoConfig: {
            apiKey?: string;
            baseApiUri?: string;
            publicKey?: string;
            webAppUriTemplate?: string;
            memberId?: string;
            memberAliasType?: string;
            validateSignature?: string;
            actingAsDisplayName?: string;
            actingAsRefId?: string;
        };
        finTsConfig: {
            apiKey?: string;
            riskApiKey?: string;
        };
        ixoConfig: {
            apiKey?: string;
            apiAuthUsername?: string;
            apiAuthPassword?: string;
        };
        TinkConfig: {
            clientId?: string;
            clientSecret?: string;
            merchantId?: string;
            useTestBanks?: boolean;
            tinkLinkUrl?: string;
            tinkLinkUrlContinuousAccess?: string;
        };
        /** @description The response model for cursor-based paged connector list. */
        GetConnectorsHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of connectors. */
            connectors?: components["schemas"]["Connector"][];
        };
        /** @description The response DTO for the CreateCustomer request */
        CreateCustomerHttpResponse: {
            customer: components["schemas"]["Customer"];
        };
        /** @description The response model for cursor-based paged customer list. */
        GetCustomersHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of customers. */
            customers?: components["schemas"]["Customer"][];
        };
        /** @description The response DTO for the GetCustomer request */
        GetCustomerHttpResponse: {
            customer: components["schemas"]["Customer"];
        };
        /** @description The response DTO for the CreateHostedPage request */
        CreateHostedPageHttpResponse: {
            hostedPage?: components["schemas"]["HostedPage"];
        };
        /** @description Parameters of a HostedPage object */
        HostedPage: {
            /** @description The unique identifier of this hosted page object. */
            id: string;
            /** @description The unique identifier of the merchant this hosted page object belongs to. */
            merchantId?: string;
            merchant?: components["schemas"]["Merchant"];
            /** @description The unique identifier of the connector this hosted page object belongs to. */
            connectorId?: string;
            connector?: components["schemas"]["Connector"];
            /** @description The unique identifier of the customer this hosted page object belongs to. */
            customerId?: string;
            customer?: components["schemas"]["Customer"];
            /** @description The unique identifier of the bank account this hosted page object belongs to. */
            bankAccountId?: string;
            bankAccount?: components["schemas"]["BankAccount"];
            /** @description The unique identifier of the mandate this hosted page object belongs to. */
            mandateId?: string;
            mandate?: components["schemas"]["Mandate"];
            /** @description The unique identifier of the payment this hosted page object belongs to. */
            paymentId?: string;
            payment?: components["schemas"]["Payment"];
            /** @description The unique identifier of the requestToPay this hosted page object belongs to. */
            requestToPayId?: string;
            requestToPay?: components["schemas"]["RequestToPay"];
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this hosted page object was created
             */
            createdAt: string;
            /** @description One of:
             *     * created - The hosted page is created and its id can be immediately used in subsequent calls to the API.
             *     * pending - The hosted page is currently displayed to the customer.
             *     * success - The hosted page workflow finished successfully.
             *     * failed - The hosted page workflow failed. */
            state?: string;
            /** @description One of:
             *      * CreateMandate */
            type?: string;
            /** @description When the hosted page has failed this contains the cause for failure. */
            cause?: string;
            /** @description When the hosted page has failed this contains the reason code for failure. */
            reasonCode?: string;
            /** @description When the hosted page has failed this contains the trigger for failure. */
            trigger?: string;
            /** @description When the hosted page has failed this contains the token for failure. */
            token?: string;
            /** @description Memo for free use by the PSP */
            memo?: string;
        };
        /** @description Parameters of a mandate object */
        Mandate: {
            /** @description The unique identifier of this mandate object. */
            id: string;
            /** @description The unique identifier of the merchant this mandate object belongs to. */
            merchantId: string;
            merchant?: components["schemas"]["Merchant"];
            /** @description The unique identifier of the connector this mandate object belongs to. */
            connectorId: string;
            connector?: components["schemas"]["Connector"];
            /** @description The unique identifier of the customer this mandate object belongs to. */
            customerId: string;
            customer?: components["schemas"]["Customer"];
            /** @description The unique identifier of the bank account this mandate object belongs to. */
            bankAccountId: string;
            bankAccount?: components["schemas"]["BankAccount"];
            /** @description The unique identifier of the mandate object replacing this mandate object.
             *     Optional. Only filled, when this mandate has been replaced by another mandate. */
            replacedByMandateId?: string;
            replacedByMandate?: components["schemas"]["Mandate"];
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this mandate object was created
             */
            createdAt: string;
            /** @description One of:
             *     * created - The mandate is created and its id can be immediately used in subsequent calls to the API. The execution
             *     of dependent subsequent calls will get postponed until this mandate object gets active.
             *     * pendingApproval - The mandate requires the approval by the customer (e.g. email and sms mandates).
             *     * pendingSecondaryApproval - The mandate requires an additional approval (e.g. permission from a second signatory),
             *     and that approval is pending.
             *     * pendingReview - The review of the mandate by the merchant is pending. Only applicable if the associated connector
             *     defines paymentMandateReview.enabled as true.
             *     * pendingSubmission - The mandate has not yet been submitted to the customer’s bank.
             *     * submitted - The mandate has been submitted to the customer’s bank, but has not been processed yet.
             *     * active - The mandate has been successfully set up.
             *     * failed - The mandate could not be set up.
             *     * discarded - The mandate has been discarded.
             *     * expired - The mandate has expired due to dormancy.
             *     * replaced - The mandate has been replaced by a new mandate. */
            state: string;
            /** @description The Direct Debit payment scheme this mandate and all dependent
             *     payments belong to. One of:
             *     * sepa - Single Euro Payments Area
             *     * bacs - Bankers Automated Clearing Services */
            scheme?: string;
            /** @description The unique reference of this mandate. Length and format dependent
             *     on regulations defined by the determined payment scheme. */
            reference?: string;
            /** @description The type of this mandate. One of:
             *     * single - The mandate can be used for a single payment. It will expire after the first payment or after a period
             *     of dormancy as defined by the payment scheme.
             *     * recurring - The mandate can be used for an unlimited number of payments. It will expire after a period of
             *     dormancy as defined by the payment scheme. */
            type: string;
            /** @description The URL of the generated mandate. This field is only filled, when the
             *     mandate generation feature is enabled in the merchant connector. */
            mandateUrl?: string;
            /** @description The URL of the generated mandate setup confirmation. This field is only filled, when the
             *     mandate setup confirmation generation feature is enabled in the merchant connector. */
            mandateSetupConfirmationUrl?: string;
            /** @description The unique idempotency key of this entity creation.
             *     Optional, but highly recommended to use. When given, SEPAexpress
             *     will check, whether an entity of this type with the given
             *     idempotency key does already exist, and will fail the creation,
             *     if a duplicate entity is found. The error message will contain
             *     the id of the conflicting entity. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP */
            memo?: string;
            /** @description Optional. Mark this mandate as not yet approved by the customer.
             *     SEPAexpress will initiate the approval process. One of:
             *     * click - Click mandate. The mandate is approved by ticking a check box and/or clicking an approve button on the web page.
             *     * email - Email mandate. The customer is sent an email containing a secret Tan and/or a link to click. The customer
             *     email address has to be filled.
             *     * sms - SMS mandate. The customer is sent a sms containing a secret Tan. The customer cellphone number has to be
             *     filled.
             *     * ais - Account Information Service mandate. The mandate is approved by using a PSD2 AIS account check via the internet
             *     banking of the customer's bank. When the amount and currency are also given in this request an additional balance check
             *     is executed.
             *     * dynamic - Dynamic mandate management. The mandate type is managed by SEPA.express based on configured parameters. */
            approvalBy?: string;
            /**
             * Format: date-time
             * @description ApprovalDate is an optional field that indicates when the mandate was signed.
             */
            approvalDate?: string | null;
            /** @description The ISO 4217 currency code. used mainly for AIS mandate with Balance Check */
            currencyCode?: string;
            /**
             * Format: int32
             * @description The max allowable amount to collect from the customer's bank account for this mandate.
             *     Specified in the smallest subunit of the used currency, e.g.
             *     cents for EUR.
             */
            amount?: number | null;
            /** @description The unique identifier of the hosted page this mandate object belongs to. */
            hostedPageId?: string;
            hostedPage?: components["schemas"]["HostedPage"];
        };
        /** @description Parameters of a payment object */
        Payment: {
            /** @description The unique identifier of this payment object. */
            id: string;
            /** @description The unique identifier of the merchant this payment object belongs to. */
            merchantId: string;
            merchant?: components["schemas"]["Merchant"];
            /** @description The unique identifier of the connector this payment object belongs to. */
            connectorId: string;
            connector?: components["schemas"]["Connector"];
            /** @description The unique identifier of the customer this payment object belongs to. */
            customerId: string;
            customer?: components["schemas"]["Customer"];
            /** @description The unique identifier of the bank account this payment object belongs to. */
            bankAccountId: string;
            bankAccount?: components["schemas"]["BankAccount"];
            /** @description The unique identifier of the mandate this payment object belongs to. */
            mandateId: string;
            mandate?: components["schemas"]["Mandate"];
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this payment object was created
             */
            createdAt: string;
            /** @description One of:
             *     * created - The payment is created and its id can be immediately used in subsequent calls to the API. The execution
             *     of dependent subsequent calls will get postponed until this payment object gets paid.
             *     * pendingApproval - The payment requires the approval by the customer.
             *     * pendingReview - The review of the payment by the merchant is pending. Only applicable if the associated connector
             *     defines paymentsNeedReview as true.
             *     * pendingSubmission - The payment has not yet been submitted toward the customer's bank.
             *     * submitted - The payment has been submitted toward the customer's bank, but the processing has not been finished
             *     yet.
             *     * paid - The payment has been successfully collected from the customer.
             *     * failed - The payment could not be set up.
             *     * discarded - The payment has been discarded.
             *     * chargedBack - The payment has been charged back by the customer’s bank. */
            state?: string;
            /** @description The ISO 4217 currency code. */
            currencyCode?: string;
            /**
             * Format: int32
             * @description The amount to collect from the customer's bank account.
             *     Specified in the smallest subunit of the used currency, e.g.
             *     cents for EUR.
             */
            amount: number;
            /** @description The unique reference of this payment. This id is used for matching
             *     payments and refunds on the participating bank accounts. Length,
             *     format and content are dependent on the regulations defined by
             *     the used payment scheme. Often called End2EndId in the SEPA scheme. */
            reference?: string;
            /** @description The soft descriptor for this payment. The text entered here will be
             *     printed on the bank statements of the participating bank accounts,
             *     if supported in the used payment scheme. */
            softDescriptor?: string;
            /**
             * Format: int32
             * @description The number of requested refunds for this payment.
             */
            refundCount?: number | null;
            /**
             * Format: int32
             * @description The amount of all requested refunds for this payment.
             *     Specified in the smallest subunit of the used currency, e.g.
             *     cents for EUR.
             */
            refundAmount?: number | null;
            /**
             * Format: date-time
             * @description Defines, when this payment should be earliest submitted
             *     to the customer's bank account. Optional. Payments will
             *     be submitted as soon as possible, when not specified.
             */
            submitAfter?: string | null;
            /** @description The URL of the generated payment pre notification. This field is only filled, when the
             *     payment pre notification generation feature is enabled in the merchant connector. */
            paymentPreNotificationUrl?: string;
            /** @description The unique idempotency key of this entity creation.
             *     Optional, but highly recommended to use. When given, SEPAexpress
             *     will check, whether an entity of this type with the given
             *     idempotency key does already exist, and will fail the creation,
             *     if a duplicate entity is found. The error message will contain
             *     the id of the conflicting entity. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP */
            memo?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding iban from the stored mandate. */
            validationIban?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding id from the stored customer. */
            validationCustomerId?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding id from the stored bank account. */
            validationBankAccountId?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding id from the stored connector. */
            validationConnectorId?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding id from the stored merchant. */
            validationMerchantId?: string;
            /** @description Optional. Mark this payment as not yet approved by the customer.
             *     SEPAexpress will initiate the approval process. One of:
             *     * ais - Account Information Service mandate. The payment is approved by using a PSD2 AIS account check via the internet
             *     banking of the customer's bank. */
            approvalBy?: string;
            /**
             * Format: date-time
             * @description ApprovalDate is an optional field that indicates when the payment was signed.
             */
            approvalDate?: string | null;
            /** @description The unique identifier of the hosted page this payment object belongs to. */
            hostedPageId?: string;
            hostedPage?: components["schemas"]["HostedPage"];
            /** @description Custom1 for free use by the PSP. */
            custom1?: string;
            /** @description Custom2 for free use by the PSP. */
            custom2?: string;
            /** @description Custom3 for free use by the PSP. */
            custom3?: string;
            /** @description Custom4 for free use by the PSP. */
            custom4?: string;
            /** @description Custom5 for free use by the PSP. */
            custom5?: string;
        };
        /** @description Parameters of a requestToPay object */
        RequestToPay: {
            /** @description The unique identifier of this requestToPay object. */
            id: string;
            /** @description The unique identifier of the merchant this requestToPay object belongs to. */
            merchantId: string;
            merchant?: components["schemas"]["Merchant"];
            /** @description The unique identifier of the connector this requestToPay object belongs to. */
            connectorId: string;
            connector?: components["schemas"]["Connector"];
            /** @description The unique identifier of the customer this requestToPay object belongs to. */
            customerId: string;
            customer?: components["schemas"]["Customer"];
            /** @description The unique identifier of the bank account this requestToPay object belongs to. */
            bankAccountId: string;
            bankAccount?: components["schemas"]["BankAccount"];
            /** @description The unique identifier of the hosted page this requestToPay object belongs to. */
            hostedPageId?: string;
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this requestToPay object was created
             */
            createdAt: string;
            /** @description One of:
             *     * created - The requestToPay is created and its id can be immediately used in subsequent calls to the API. The execution
             *     of dependent subsequent calls will get postponed until this requestToPay object gets paid.
             *     * pendingApproval - The requestToPay requires the approval by the customer.
             *     * pendingReview - The review of the requestToPay by the merchant is pending. Only applicable if the associated connector
             *     defines paymentsNeedReview as true.
             *     * pendingSubmission - The requestToPay has not yet been submitted toward the customer's bank.
             *     * submitted - The requestToPay has been submitted toward the customer's bank, but the processing has not been finished
             *     yet.
             *     * paid - The requestToPay has been successfully collected from the customer.
             *     * failed - The requestToPay could not be set up.
             *     * discarded - The requestToPay has been discarded.
             *     * chargedBack - The requestToPay has been charged back by the customer’s bank. */
            state?: string;
            /**
             * Format: date-time
             * @description ApprovalDate is an optional field that indicates when the requestToPay object was approved.
             */
            approvalDate?: string | null;
            /** @description The ISO 4217 currency code. */
            currencyCode?: string;
            /**
             * Format: int32
             * @description The amount to collect from the customer's bank account.
             *     Specified in the smallest subunit of the used currency, e.g.
             *     cents for EUR.
             */
            amount: number;
            /** @description The unique reference of this requestToPay. This id is used for matching
             *     payments and refunds on the participating bank accounts. Length,
             *     format and content are dependent on the regulations defined by
             *     the used requestToPay scheme. Often called End2EndId in the SEPA scheme. */
            reference?: string;
            /** @description The soft descriptor for this requestToPay. The text entered here will be
             *     printed on the bank statements of the participating bank accounts,
             *     if supported in the used requestToPay scheme. */
            softDescriptor?: string;
            /** @description The unique idempotency key of this entity creation.
             *     Optional, but highly recommended to use. When given, SEPAexpress
             *     will check, whether an entity of this type with the given
             *     idempotency key does already exist, and will fail the creation,
             *     if a duplicate entity is found. The error message will contain
             *     the id of the conflicting entity. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP */
            memo?: string;
            /** @description Custom1 for free use by the PSP. */
            custom1?: string;
            /** @description Custom2 for free use by the PSP. */
            custom2?: string;
            /** @description Custom3 for free use by the PSP. */
            custom3?: string;
            /** @description Custom4 for free use by the PSP. */
            custom4?: string;
            /** @description Custom5 for free use by the PSP. */
            custom5?: string;
        };
        /** @description The response model for cursor-based paged customer list. */
        GetHostedPagesHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of HostedPages. */
            hostedPages?: components["schemas"]["HostedPage"][];
        };
        /** @description The response DTO for the GetHostedPage request */
        GetHostedPageHttpResponse: {
            hostedPage: components["schemas"]["HostedPage"];
        };
        /** @description The response model for GetLocalizationText list. */
        GetLocalizationTextHttpResponse: {
            localizationText: components["schemas"]["LocalizationText"];
        };
        /** @description Parameters of a mandate object */
        LocalizationText: {
            /** @description The unique identifier of this mandate object. */
            key?: string;
            /** @description The unique identifier of the merchant this mandate object belongs to. */
            merchantId: string;
            languageCode?: string;
            countryCode?: string;
            text?: string;
        };
        CreateMandateHttpResponse: {
            mandate: components["schemas"]["Mandate"];
        };
        /** @description The response model for cursor-based paged mandate list. */
        GetMandatesHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of mandates. */
            mandates?: components["schemas"]["Mandate"][];
        };
        /** @description The response model for cursor-based paged mandate list. */
        GetMandateHttpResponse: {
            mandate: components["schemas"]["Mandate"];
        };
        ApproveMandateHttpResponse: {
            mandate: components["schemas"]["Mandate"];
        };
        ResendMandateHttpResponse: {
            mandate: components["schemas"]["Mandate"];
        };
        ReviewMandateHttpResponse: {
            mandate: components["schemas"]["Mandate"];
        };
        DiscardMandateHttpResponse: {
            mandate: components["schemas"]["Mandate"];
        };
        ReinstateMandateHttpResponse: {
            mandate: components["schemas"]["Mandate"];
        };
        /** @description The response DTO for the GetMerchant request */
        GetMerchantHttpResponse: {
            merchant: components["schemas"]["Merchant"];
        };
        /** @description The response model for cursor-based paged merchant list. */
        GetMerchantsHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of merchants. */
            merchants?: components["schemas"]["Merchant"][];
        };
        CreatePaymentHttpResponse: {
            payment: components["schemas"]["Payment"];
            error?: components["schemas"]["Error"];
        };
        /** @description The response model for cursor-based paged payment list. */
        GetPaymentsHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of payments. */
            payments?: components["schemas"]["Payment"][];
        };
        /** @description The response DTO for the GetPayment request */
        GetPaymentHttpResponse: {
            payment: components["schemas"]["Payment"];
        };
        ReviewPaymentHttpResponse: {
            payment: components["schemas"]["Payment"];
        };
        CreatePayoutHttpResponse: {
            payout: components["schemas"]["Payout"];
        };
        /** @description Parameters of a payout object */
        Payout: {
            /** @description The unique identifier of this payout object. */
            id: string;
            /** @description The unique identifier of the merchant this payout object belongs to. */
            merchantId: string;
            merchant?: components["schemas"]["Merchant"];
            /** @description The unique identifier of the connector this payout object belongs to. */
            connectorId: string;
            connector?: components["schemas"]["Connector"];
            /** @description The unique identifier of the customer this payout object belongs to. */
            customerId: string;
            customer?: components["schemas"]["Customer"];
            /** @description The unique identifier of the bank account this payout object belongs to. */
            bankAccountId: string;
            bankAccount?: components["schemas"]["BankAccount"];
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this payout object was created
             */
            createdAt: string;
            /** @description One of:
             *     * created - The payout is created and its id can be immediately used in subsequent calls to the API. The execution
             *     of dependent subsequent calls will get postponed until this payout object gets active.
             *     * pendingReview - The review of the payout by the merchant is pending. Only applicable if the associated connector
             *     defines payoutsNeedReview as true.
             *     * pendingSubmission - The payout has not yet been submitted toward the customer's bank.
             *     * submitted - The payout has been submitted toward the customer's bank, but the processing has not been finished
             *     yet.
             *     * paid - The payout has been successfully collected from the customer.
             *     * failed - The payout could not be set up.
             *     * discarded - The payout has been discarded. */
            state: string;
            /** @description The ISO 4217 currency code. */
            currencyCode?: string;
            /**
             * Format: int32
             * @description The amount to collect from the customer's bank account.
             *     Specified in the smallest subunit of the used currency, e.g.
             *     cents for EUR.
             */
            amount?: number;
            /** @description The unique reference of this payout. This id is used for matching
             *     payouts and refunds on the participating bank accounts. Length,
             *     format and content are dependent on the regulations defined by
             *     the used payout scheme. */
            reference?: string;
            /** @description The soft descriptor for this payout. The text entered here will be
             *     printed on the bank statements of the participating bank accounts,
             *     if supported in the used payout scheme. */
            softDescriptor?: string;
            /**
             * Format: date-time
             * @description Defines, when this payout should be earliest submitted
             *     to the customer's bank account. Optional. Payouts will
             *     be submitted as soon as possible, when not specified.
             */
            submitAfter?: string | null;
            /** @description The unique idempotency key of this entity creation.
             *     Optional, but highly recommended to use. When given, SEPAexpress
             *     will check, whether an entity of this type with the given
             *     idempotency key does already exist, and will fail the creation,
             *     if a duplicate entity is found. The error message will contain
             *     the id of the conflicting entity. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP */
            memo?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding iban from the stored mandate. */
            validationIban?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding id from the stored customer. */
            validationCustomerId?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding id from the stored connector. */
            validationConnectorId?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding id from the stored merchant. */
            validationMerchantId?: string;
            /** @description Custom1 for free use by the PSP. */
            custom1?: string;
            /** @description Custom2 for free use by the PSP. */
            custom2?: string;
            /** @description Custom3 for free use by the PSP. */
            custom3?: string;
            /** @description Custom4 for free use by the PSP. */
            custom4?: string;
            /** @description Custom5 for free use by the PSP. */
            custom5?: string;
        };
        /** @description The response model for cursor-based paged payout list. */
        GetPayoutsHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of payouts. */
            payouts?: components["schemas"]["Payout"][];
        };
        /** @description The response DTO for the GetPayout request */
        GetPayoutHttpResponse: {
            payout: components["schemas"]["Payout"];
        };
        ReviewPayoutHttpResponse: {
            payout: components["schemas"]["Payout"];
        };
        /** @description The response DTO for the GetReconciliation request */
        GetReconciliationHttpResponse: {
            reconciliation: components["schemas"]["Reconciliation"];
        };
        /** @description Parameters of a reconciliation object */
        Reconciliation: {
            /** @description The unique identifier of this reconciliation object. */
            id: string;
            /** @description The unique identifier of the merchant this reconciliation object
             *     belongs to. Optional. */
            merchantId?: string;
            merchant?: components["schemas"]["Merchant"];
            /** @description The unique identifier of the connector this reconciliation object
             *     belongs to. Optional. */
            connectorId?: string;
            connector?: components["schemas"]["Connector"];
            /** @description The unique identifier of the customer this reconciliation object
             *     belongs to. Optional. */
            customerId?: string;
            customer?: components["schemas"]["Customer"];
            /** @description The unique identifier of the bank account this reconciliation object
             *     belongs to. Optional. */
            bankAccountId?: string;
            bankAccount?: components["schemas"]["BankAccount"];
            /** @description The unique identifier of the mandate this reconciliation object
             *     belongs to. Optional. */
            mandateId?: string;
            mandate?: components["schemas"]["Mandate"];
            /** @description The unique identifier of the payment this reconciliation object
             *     belongs to. Optional. */
            paymentId?: string;
            Payment?: components["schemas"]["Payment"];
            /** @description The unique identifier of the refund this reconciliation object
             *     belongs to. Optional. */
            refundId?: string;
            refund?: components["schemas"]["Refund"];
            /** @description The unique identifier of the payout this reconciliation object
             *     belongs to. Optional. */
            payoutId?: string;
            payout?: components["schemas"]["Payout"];
            /** @description The unique identifier of the RequestToPay this reconciliation object
             *     belongs to. Optional. */
            requestToPayId?: string;
            requestToPay?: components["schemas"]["RequestToPay"];
            /** @description The unique identifier of the HostedPage this reconciliation object
             *     belongs to. Optional. */
            hostedPageId?: string;
            hostedPage?: components["schemas"]["HostedPage"];
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this reconciliation object was created
             */
            createdAt: string;
            /** @description The entity this reconciliation belongs to. One of:
             *     * payment
             *     * payout
             *     * refund */
            entity?: string;
            /** @description One of:
             *     * paid
             *     * failed
             *     * discarded
             *     * chargedBack */
            state?: string;
            /** @description The ISO 13616 international bank account number */
            iban?: string;
            /** @description The ISO 4217 currency code. */
            currencyCode?: string;
            /**
             * Format: int32
             * @description The amount of the transaction.
             *     Specified in the smallest subunit of the used currency, e.g.
             *     cents for EUR.
             */
            amount?: number;
            /** @description The unique reference of this transaction. This id is used for matching
             *     payments and refunds on the participating bank accounts. Length,
             *     format and content are dependent on the regulations defined by
             *     the used payment scheme. Often called End2EndId in the SEPA scheme. */
            reference?: string;
            /** @description The unique transaction id of this transaction defined by the PSP.
             *     Optional, but highly recommended to use. */
            idempotencyKey?: string;
            /**
             * Format: date-time
             * @description The booking date equals the settlement date on the bank account and
             *     is important for accounting and reconciliation. The value date can
             *     be one day later.
             */
            bookingDate?: string;
            /** @description What triggered this reconciliation entry. Optional. Only
             *     filled when a bank report is the origin of this reconciliation
             *     entry. */
            cause?: string;
            /** @description The payment scheme this reconciliation belongs to. Optional. Only
             *     filled when a bank report is the origin of this reconciliation.
             *     entry. One of:
             *     * sepa - Single Euro Payments Area
             *     * bacs - Bankers Automated Clearing Services */
            scheme?: string;
            /** @description The reason code. Optional. */
            reasonCode?: string;
            /** @description The trigger. Optional. */
            trigger?: string;
            /** @description The token. Optional. */
            token?: string;
            /** @description The info for this reconciliation. Optional. */
            info?: string;
            /** @description The memo for this reconciliation. Optional. */
            memo?: string;
        };
        /** @description Parameters of a refund object */
        Refund: {
            /** @description The unique identifier of this refund object. */
            id: string;
            /** @description The unique identifier of the merchant this refund object belongs to. */
            merchantId: string;
            merchant?: components["schemas"]["Merchant"];
            /** @description The unique identifier of the connector this refund object belongs to. */
            connectorId: string;
            connector?: components["schemas"]["Connector"];
            /** @description The unique identifier of the customer this refund object belongs to. */
            customerId: string;
            customer?: components["schemas"]["Customer"];
            /** @description The unique identifier of the bank account this refund object belongs to. */
            bankAccountId: string;
            bankAccount?: components["schemas"]["BankAccount"];
            /** @description The unique identifier of the mandate this refund object belongs to. */
            mandateId?: string;
            mandate?: components["schemas"]["Mandate"];
            /** @description The unique identifier of the payment this refund object belongs to. */
            paymentId: string;
            payment?: components["schemas"]["Payment"];
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this refund object was created
             */
            createdAt: string;
            /** @description One of:
             *     * created - The refund is created and its id can be immediately used in subsequent calls to the API. The execution
             *     of dependent subsequent calls will get postponed until this refund object gets active.
             *     * pendingReview - The review of the refund by the merchant is pending. Only applicable if the associated connector
             *     defines refundsNeedReview as true.
             *     * pendingSubmission - The refund has not yet been submitted toward the customer's bank.
             *     * submitted - The refund has been submitted toward the customer's bank, but the processing has not been finished
             *     yet.
             *     * paid - The refund has been successfully paid to the customer.
             *     * failed - The refund could not be set up.
             *     * discarded - The refund has been discarded. */
            state?: string;
            /** @description The ISO 4217 currency code. */
            currencyCode?: string;
            /**
             * Format: int32
             * @description The amount to refund to the customer's bank account.
             *     Specified in the smallest subunit of the used currency, e.g.
             *     cents for EUR.
             */
            amount?: number;
            /** @description The unique reference of this refund. This id is used for matching
             *     payments and refunds on the participating bank accounts. Length,
             *     format and content are dependent on the regulations defined by
             *     the used payment scheme. */
            reference?: string;
            /** @description The soft descriptor for this refund. The text entered here will be
             *     printed on the bank statements of the participating bank accounts,
             *     if supported in the used refund scheme. */
            softDescriptor?: string;
            /**
             * Format: date-time
             * @description Defines, when this refund should be earliest submitted
             *     to the customer's bank account. Optional. Refunds will
             *     be submitted as soon as possible, when not specified.
             */
            submitAfter?: string | null;
            /** @description The unique idempotency key of this entity creation.
             *     Optional, but highly recommended to use. When given, SEPAexpress
             *     will check, whether an entity of this type with the given
             *     idempotency key does already exist, and will fail the creation,
             *     if a duplicate entity is found. The error message will contain
             *     the id of the conflicting entity. */
            idempotencyKey?: string;
            /** @description Memo for free use by the PSP */
            memo?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding id from the stored customer. */
            validationCustomerId?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding id from the stored bank account. */
            validationBankAccountId?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding id from the stored connector. */
            validationConnectorId?: string;
            /** @description If provided, it will result in an validation error if the content is different to the corresponding id from the stored merchant. */
            validationMerchantId?: string;
            /** @description Custom1 for free use by the PSP. */
            custom1?: string;
            /** @description Custom2 for free use by the PSP. */
            custom2?: string;
            /** @description Custom3 for free use by the PSP. */
            custom3?: string;
            /** @description Custom4 for free use by the PSP. */
            custom4?: string;
            /** @description Custom5 for free use by the PSP. */
            custom5?: string;
        };
        /** @description The response model for cursor-based paged reconciliation list. */
        GetReconciliationsHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of reconciliations. */
            reconciliations?: components["schemas"]["Reconciliation"][];
        };
        CreateRefundHttpResponse: {
            refund: components["schemas"]["Refund"];
        };
        /** @description The response model for cursor-based paged refund list. */
        GetRefundsHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of refunds. */
            refunds?: components["schemas"]["Refund"][];
        };
        /** @description The response DTO for the GetRefund request */
        GetRefundHttpResponse: {
            refund: components["schemas"]["Refund"];
        };
        ReviewRefundHttpResponse: {
            refund: components["schemas"]["Refund"];
        };
        CreateRequestToPayHttpResponse: {
            requestToPay: components["schemas"]["RequestToPay"];
            error?: components["schemas"]["Error"];
        };
        /** @description The response model for cursor-based paged payment list. */
        GetRequestsToPayHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of payments. */
            requestsToPay?: components["schemas"]["RequestToPay"][];
        };
        /** @description The response DTO for the GetRequestToPay request */
        GetRequestToPayHttpResponse: {
            requestToPay: components["schemas"]["RequestToPay"];
        };
        /** @description The response DTO for the GetProcess request */
        GetProcessHttpResponse: {
            process: components["schemas"]["Process"];
        };
        /** @description Parameters of a process object */
        Process: {
            /** @description The unique identifier of this process object. */
            id: string;
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this process object was created
             */
            createdAt: string;
            /** @description Process’s type */
            type: string;
            /** @description Process’s origin
             *     One of:
             *     * Api
             *     * Bank
             *     * Internal
             *     * User */
            origin: string;
            /** @description Process’s name.
             *     One of:
             *     * Http
             *     * Queue
             *     * Timer */
            name?: string;
        };
        /** @description The response model for cursor-based paged process list. */
        GetProcessesHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of processes. */
            processes?: components["schemas"]["Process"][];
        };
        /** @description The response DTO for the GetProcessEvent request */
        GetProcessEventHttpResponse: {
            processEvent: components["schemas"]["ProcessEvent"];
        };
        /** @description Parameters of a process event object */
        ProcessEvent: {
            /** @description The unique identifier of this process event object. */
            id: string;
            /** @description The unique identifier of the merchant this process event object
             *     belongs to. Optional. */
            merchantId?: string;
            merchant?: components["schemas"]["Merchant"];
            /** @description The unique identifier of the connector this process event object
             *     belongs to. Optional. */
            connectorId?: string;
            connector?: components["schemas"]["Connector"];
            /** @description The unique identifier of the customer this process event object
             *     belongs to. Optional. */
            customerId?: string;
            customer?: components["schemas"]["Customer"];
            /** @description The unique identifier of the bank account this process event object
             *     belongs to. Optional. */
            bankAccountId?: string;
            bankAccount?: components["schemas"]["BankAccount"];
            /** @description The unique identifier of the HostedPage this process event object
             *     belongs to. Optional. */
            hostedPageId?: string;
            hostedPage?: components["schemas"]["HostedPage"];
            /** @description The unique identifier of the mandate this process event object
             *     belongs to. Optional. */
            mandateId?: string;
            mandate?: components["schemas"]["Mandate"];
            /** @description The unique identifier of the payment this process event object
             *     belongs to. Optional. */
            paymentId?: string;
            payment?: components["schemas"]["Payment"];
            /** @description The unique identifier of the refund this process event object
             *     belongs to. Optional. */
            refundId?: string;
            refund?: components["schemas"]["Refund"];
            /** @description The unique identifier of the payout this process event object
             *     belongs to. Optional. */
            payoutId?: string;
            payout?: components["schemas"]["Payout"];
            /** @description The unique identifier of the process this process event object
             *     belongs to. */
            processId?: string;
            process?: components["schemas"]["Process"];
            /** @description The unique identifier of the reconciliation this process event object
             *     belongs to. Optional. */
            reconciliationId?: string;
            reconciliation?: components["schemas"]["Reconciliation"];
            /** @description The unique identifier of the requestToPay this process event object
             *     belongs to. Optional. */
            requestToPayId?: string;
            requestToPay?: components["schemas"]["RequestToPay"];
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this process event object was created
             */
            createdAt: string;
            /** @description The type of this process event object. */
            type?: string;
            /** @description What triggered this process event. Optional. */
            cause?: string;
            /** @description The reason code. Optional. */
            reasonCode?: string;
            /** @description The description. Optional. */
            description?: string;
            /** @description The recommended action. Optional. */
            action?: string;
            /** @description The best practice to follow. Optional. */
            bestPractice?: string;
            idempotencyKey?: string;
            /** @description The data of this process event. Optional. */
            data?: unknown[];
        };
        /** @description The response model for cursor-based paged webhook event list. */
        GetProcessEventsHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of processEvents. */
            processEvents?: components["schemas"]["ProcessEvent"][];
        };
        /** @description The response DTO for the GetWebhook request */
        GetWebhookHttpResponse: {
            webhook: components["schemas"]["Webhook"];
        };
        /** @description Parameters of a web hook object */
        Webhook: {
            /** @description The unique identifier of this web hook object. */
            id: string;
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this web hook object was created
             */
            createdAt: string;
            /** @description One of:
             *     * created - The web hook is created and its id can be immediately used in subsequent calls to the API. The
             *     execution of dependent subsequent calls will get postponed until this webhook object gets active.
             *     * active - The web hook has been successfully set up.
             *     * failed - The web hook could not be set up.
             *     * discarded - The web hook has been discarded. */
            state?: string;
            /** @description The URL of the server that will receive the web hook POST requests.
             *     Only HTTPS endpoints supporting TLS 1.2 are supported. */
            url?: string;
            /** @description Setting a web hook secret allows you to ensure that POST requests
             *     sent to the configured URL are from SEPAexpress. When you set a
             *     secret, you'll receive the X-Hub-Signature header in the web hook
             *     POST request. */
            secret?: string;
            /** @description Set additional HTTP headers in the web hook request.  Optional. */
            additionalHeaders?: components["schemas"]["Header"][];
            configuration?: components["schemas"]["WebhookConfiguration"];
            /** @description Memo for free use by the PSP */
            memo?: string;
        };
        Header: {
            /** @description The header name. */
            name: string;
            /** @description The header name. */
            value: string;
        };
        /** @description The request DTO for the CreateWebhook request */
        WebhookConfiguration: {
            merchants?: string[];
            connectors?: string[];
            eventTypes?: string[];
            includeMerchant?: boolean;
            includeConnector?: boolean;
            includeCustomer?: boolean;
            includeBankAccount?: boolean;
            includeMandate?: boolean;
            includePayment?: boolean;
            includePayout?: boolean;
            includeProcess?: boolean;
            includeReconciliation?: boolean;
            includeRefund?: boolean;
        };
        /** @description The response model for cursor-based paged web hook list. */
        GetWebhooksHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of web hooks. */
            webhooks: components["schemas"]["Webhook"][];
        };
        /** @description The response DTO for the GetWebhookEventTransmission request */
        GetWebhookEventTransmissionHttpResponse: {
            webhookEventTransmission: components["schemas"]["WebhookEventTransmission"];
        };
        /** @description Parameters of a webhookEventTransmission object */
        WebhookEventTransmission: {
            /** @description The unique identifier of this webhookEventTransmission object. */
            id: string;
            /**
             * Format: date-time
             * @description Fixed timestamp, recording when this webhookEventTransmission object was created
             */
            createdAt: string;
            /**
             * Format: int32
             * @description Http status code
             */
            statusCode?: number;
            data?: components["schemas"]["Data"];
            /** @description The unique identifier of the merchant this webhookEventTransmission object
             *     belongs to. Optional. */
            merchantId?: string;
            merchant?: components["schemas"]["Merchant"];
            /** @description The unique identifier of the connector this webhookEventTransmission object
             *     belongs to. Optional. */
            connectorId?: string;
            connector?: components["schemas"]["Connector"];
            /** @description The unique identifier of the customer this webhookEventTransmission object
             *     belongs to. Optional. */
            customerId?: string;
            customer?: components["schemas"]["Customer"];
            /** @description The unique identifier of the bank account this webhookEventTransmission object
             *     belongs to. Optional. */
            bankAccountId?: string;
            bankAccount?: components["schemas"]["BankAccount"];
            /** @description The unique identifier of the mandate this webhookEventTransmission object
             *     belongs to. Optional. */
            mandateId?: string;
            mandate?: components["schemas"]["Mandate"];
            /** @description The unique identifier of the payment this webhookEventTransmission object
             *     belongs to. Optional. */
            paymentId?: string;
            Payment?: components["schemas"]["Payment"];
            /** @description The unique identifier of the refund this webhookEventTransmission object
             *     belongs to. Optional. */
            refundId?: string;
            refund?: components["schemas"]["Refund"];
            /** @description The unique identifier of the payout this webhookEventTransmission object
             *     belongs to. Optional. */
            payoutId?: string;
            payout?: components["schemas"]["Payout"];
            /** @description The unique identifier of the process this webhookEventTransmission object
             *     belongs to. Optional. */
            processId?: string;
            process?: components["schemas"]["Process"];
            /** @description The unique identifier of the webhookEvent this webhookEventTransmission object
             *     belongs to. Optional. */
            processEventId?: string;
            processEvent?: components["schemas"]["ProcessEvent"];
            /** @description The unique identifier of the reconciliation this webhookEventTransmission object
             *     belongs to. Optional. */
            reconciliationId?: string;
            reconciliationEvent?: components["schemas"]["Reconciliation"];
            /** @description The unique identifier of the webhook this webhookEventTransmission object
             *     belongs to. Optional. */
            webhookId?: string;
            webhook?: components["schemas"]["Webhook"];
            /** @description The unique identifier of the webhook event this webhookEventTransmission object
             *     belongs to. Optional. */
            webhookEventId?: string;
            webhookEvent?: components["schemas"]["Webhook"];
        };
        Data: {
            httpRequest?: components["schemas"]["HttpRequest"];
            httpResponse?: components["schemas"]["HttpResponse"];
        };
        HttpRequest: {
            requestUrl?: string;
            headers?: {
                [key: string]: string[];
            };
            cookies?: {
                [key: string]: string;
            };
            httpMethod?: string;
            body?: Record<string, never>;
        };
        HttpResponse: {
            /** Format: int32 */
            statusCode?: number | null;
            body?: Record<string, never>;
            headers?: {
                [key: string]: string[];
            };
        };
        /** @description The response model for cursor-based paged webHookEventTransmission list. */
        GetWebhookEventTransmissionsHttpResponse: {
            meta?: components["schemas"]["CursorPagedMeta"];
            /** @description List of webHookEventTransmissions. */
            webhookEventTransmissions?: components["schemas"]["WebhookEventTransmission"][];
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export type operations = Record<string, never>;
